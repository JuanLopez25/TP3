commit 80 primer refactor
commit 154 refactor de "avanzar tiempo"
commit 168 ya no sirven los condicionales y deshechar los paquetes, hay que guardarlos temporalmente los restantes en una "cola" del centro (nos damos cuenta gracias al fail del test "Verificar cantidad de paquetes en Destino agregando 2 paquete y procesandolos de mas para que se queden en el Destino" en el localSinLimite.test.js)
commit 170 lo logramos solucionar
terminamos de meter los limites de procesamiento para el commit 173
commmit 189 eliminamos los test de paquete ya que quedaron obsoletos
Rediseñamos la clase paquete para que tenga el nivel de urgencia
commit 336 cambio en colas de espera 
commit 356 funcionan colas de esperar variables con matrices de varios locales y los obliga a cumplir los limites de la consigna
commit 461 hemos logrado que los paquetes se mueven en diagonal pero sin tener en cuenta al destino que deben llegar
commit 461 tenemos la version de que entran x paquetes a ser procesados y x paquetes a la cola, todo a la vez
A partir del commit 463 tenemos la version de que no podes meter mas de los aceptados cola
Cambiamos los test en los cuales existe 1 centro de distribucion en el medio xq los une
COMMIT NUMERO 537 FUNCIONA LA BESTIA, FALTA AGREGAR LISTA DE SALIDA Y PERFECCIONAR CODIGO, Y QUE NO SE PUEDA CREAR LA MATRIZ CON MAS FILAS QUE COLUMNAS





CAMBIAR NOMBRES A LOS TEST
COMMIT NUMERO 573 TP COMPLETADO CON LA CONSIGNA
COMMIT 574 TODO REFACTOR

TDD

array.sort
array.splice
array.find
array.push
array.forEach
biblioteca mathjs

thorw error cuando se crea mal la matriz
protocolos para todos los archivos
refactors
funciones que retornan si se cumplen condiciones
module pattern para instanciar locales y paquetes
modulo pattern para las funciones de los centros




1_ Mysterious name: consiste en cambiar los nombres de las funciones, las variables y los "field"¿?
2_ Duplicted code: Podemos extraer la funcion, slide statements (si uno se encuentra con el codigo no es identico), pull up method (si el codigo se encuentra en subclases)
3_ Code smells, funciones con mas de 10 lineas de codigo deben hacernos dudar: Podemos extraer la funcion, si posee demasiados parametro ponerlos en un objeto
4_ Longo parameter list, no se pueden tener mas de tres o cuatro parametros en el método.
5_ fijarse si un cambio dispara errores en varias clases o si tira varios errores en una sola clase.
6_ Feature envy: sucede cuando un modulo se pasa mas hablando con otro modulo que con sus propias caracteristicas.
7_ Data clumps: si una clase contiene variables repetidad deberian agruparse en una unica clase propia.

MEGA IMPORTANTE
8_REPEATED SWITCHES: no se deben usar las sentencias de decision: reemplzarlas por un condicional
MEGA IMPORTANTE

9_ Podemos decir que usamos lo de sacar los loops.

10_ Speculative generality: una funcionalidad que, al momento de diseño se penso que iba a ser genial, pero en realidad nunca fue necesaria (nombre en los centros)
11_ Temporay field: un campo de un objeto que solo es util en determinadas circunstancias.
12_ Massage chains¿?
13_ Middel man una clase que lo unico que hace es delegar la tarea a otra clase
14_ Insider trading: los modulos deben ser desiñados de forma solida y al intercambiar datos en exceso aumenta el acomplamiento
15_Large class, una clase con demsiados campos, metodos y lineas de codigo.
16_ Alternative classes with diferrent interfaces: dos clases que realizan la misma funcionalidad pero sus interfaces son diferentes (nombres o parametros)
17_ Data class, una clase que solo contiene valores en sus propiedades y su funcionalidad solo se limita a setter y getters.
18_ Replace superclass with delegate: lo tenemos
19_ Principio SRP (delegar actividades)
20_ OCP: que un cambio en un modulo no delege en una cascada de errores
21_ ISP: separar interfaces de manera tal que podamos tener interfaces mas pequeñas y que no todas deban obtenrse de la misma.
