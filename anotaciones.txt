commit 80 primer refactor
commit 154 refactor de "avanzar tiempo"
commit 168 ya no sirven los condicionales y deshechar los paquetes, hay que guardarlos temporalmente los restantes en una "cola" del centro (nos damos cuenta gracias al fail del test "Verificar cantidad de paquetes en Destino agregando 2 paquete y procesandolos de mas para que se queden en el Destino" en el localSinLimite.test.js)
commit 170 lo logramos solucionar
terminamos de meter los limites de procesamiento para el commit 173
commmit 189 eliminamos los test de paquete ya que quedaron obsoletos
Rediseñamos la clase paquete para que tenga el nivel de urgencia
commit 336 cambio en colas de espera 
commit 356 funcionan colas de esperar variables con matrices de varios locales y los obliga a cumplir los limites de la consigna
commit 461 hemos logrado que los paquetes se mueven en diagonal pero sin tener en cuenta al destino que deben llegar
commit 461 tenemos la version de que entran x paquetes a ser procesados y x paquetes a la cola, todo a la vez
A partir del commit 463 tenemos la version de que no podes meter mas de los aceptados cola
Cambiamos los test en los cuales existe 1 centro de distribucion en el medio xq los une
COMMIT NUMERO 537 FUNCIONA LA BESTIA, FALTA AGREGAR LISTA DE SALIDA Y PERFECCIONAR CODIGO, Y QUE NO SE PUEDA CREAR LA MATRIZ CON MAS FILAS QUE COLUMNAS





CAMBIAR NOMBRES A LOS TEST
COMMIT NUMERO 573 TP COMPLETADO CON LA CONSIGNA
COMMIT 574 TODO REFACTOR

TDD

array.sort
array.splice
array.find
array.push
array.forEach
biblioteca mathjs

thorw error cuando se crea mal la matriz
protocolos para todos los archivos
refactors
funciones que retornan si se cumplen condiciones
module pattern para instanciar locales y paquetes
modulo pattern para las funciones de los centros



1.	Mysterious name: consiste en cambiar los nombres de las funciones, las variables y los "field". Consideramos que esto es fundamental para la comprensión del código, por lo tanto lo primero que debemos hacer es cambiarle los nombres a las funciones y variables de manera tal que contengan un nombre representativo:
a.	Empezamos por el método “proceso” en el archivo local.js línea 66. Proponemos cambiar el nombre de la funcion a “obtenerPaquetesProcesados”, la idea de esta funcion es obtener los paquetes que se procesaron en cada tiempo en los centros de dicho local.
b.	Un cambio en el nombre de la variable “paquetesDeLocales” a “paquetesDeLocalesProcesados” en el archivo matrizLocales.js. La idea de esta variable era representar a una matriz con los paquetes que ya fueron procesados en cada centro respectivamente.
c.	En el archivo de local.js el atributo “centrosCreados” lo cambiaremos a simplemente “centros”, dado que tendrá una lista con sus centros y su respectivo destino.
d.	En el archivo matrizLocales.js le cambiamos el nombre al atributo “cantidadCentros” dado que es confuso con la cantidad de centros de los locales porque “cantidadCentros” en la matriz no contiene al destino. Por lo tanto el atributo pasará de llamarse “cantidadCentros” a llamarse “cantidadColumnas”.
e.	En el archivos matrizLocales.js cambiamos el nombre de la variable “arribaOAbajo” en los métodos “aCualMoverme” y en “analizarMovimientos” por el nombre “subirOBajar” ya que la variable representa un 1 si el paquete debe subir, un -1 si debe bajar o un 0 si se debe mantener en la fila actual.
f.	Le cambiamos el nombre al método “procesarPaquetesPermitidos” del archivo matrizLocales.js dado que la idea es que la funcion encole en los centros de los locales los paquetes “permitidos”, por ende su nuevo nombre será “encolarPaquetesPermitidos”.
g.	Cambiamos también el nombre a la variable “paquetesQueDePuedenProcesasar” a “paquetesQueSePuedenProcesar”, que por un error de tipeo estaba mal escrita en el método “encolarPaquetesPermitidos” del archivo matrizLocales.js.
h.	Cambiamos en los centros, y en el módulos de las funciones de los centros el nombre del método “puedeEntrarACola()” por “espacioEnCola” ya que retorna el espacio que hay disponible en la cola.
i.	Cambiamos el nombre de los parámetros fila y columna que se le pasan a la funcion “aCualMoverme” en las líneas 85 y 96. El nombre pasa a ser “filaQueEstoy”, “columnasQueQuedan” ya que generaba confusión porque representan cosas distintas


2.	En “procesarPaquetesDelDestino” en el archivos matrizLocales.js en la línea 54, creamos una variable denominada “columna” la cual es redundante, por lo tanto la eliminamos.

3.	Tenemos un condicional entre las líneas 65-67 del archivo matrizLocales.js el cual es redundante, debido a que se utilizaba para no procesar los paquetes que no pertenecieran a dicho destino, esto es un caso de “Speculative generality” en donde se pensó a la hora del diseño que seria útil, pero luego nos dimos cuenta de que no es así.

4.	Luego entre las líneas 73-75 tenemos un “else” que es redundante, debido a que si no tiene paquetes para procesar (esto se debe a que los paquetesAProcesar==0) el destino procesa paquetes vacíos, lo cual no es necesario y complejiza el código. 

5.	Con los refactors realizados al método procesarPaquetesDelDestino logramos acortarlo unas 5 líneas de código.

6.	Creo que es un tema mas de prolijidad pero no hace falta instanciar con un determinado valor la variable columna en el método “analizarMovimientos” del archivo matrizLocales.js

7.	Sacamos la variable productos en paquete dado que es redundante y creamos un método que sea para agregar productos a un paquete. Teniendo así que pasar por parámetros menos variables.

8.	Un método redundante es el de “paquetesColaDeSalida” en local.js, el cual antes era de utilidad y dejo de serlo. Lo mismo sucede con el test LocalSinUrgencia.test.js, el cual solo utilizaba este método y verificaba que los paquetes estén siendo procesados. Lo mismo sucede con su método “avanzarTiempo” el cual se utilizaba en un principio para avanzar el tiempo en el local, que luego fue trasladado a “matrizLocales.js” quien se ocupada de que avance el tiempo en todos los locales.

9.	Es redundante e incensario pasarle por parámetro al destino su numero de Destino, debido a que estará asociado a un local en una matriz y corresponde a una determinada fila, por lo tanto no solo podemos dejar de pasar por parámetro el numero de destino, sino que también, podemos dejar de tener el atributo en destino.js y también podemos dejar de tener un contador en local.js que corresponda al número de destino. Como consecuencia de esto no tenemos mas que resetear el contador de destino en el método “resetearID”.

10.	 Podemos agregar al método “resetearID” una línea de código que sea: “this.nombre=contadorOrigen” por lo tanto cuando queremos resetear id podemos hacerlo con el primer local creado, y no crear un local auxiliar solo para esto. (Fijarse si se puede)

11.	 Podemos agregar al método “resetearID” una línea de código que sea: “ this.id=contador” por lo tanto cuando queremos resetear id podemos hacerlo con el primer paquete creado, y no crear un paquete auxiliar solo para esto.

12.	 Podemos remover una serie de condicionales que se encuentran en el método  “procesarPaquetesPermitidos” en el archivo matrizLocales.js con polimorfismo, esto además nos permite remover de esta clase 3 métodos los cuales son: “limitesMismoLocal”, “limitesLocalSuperior” y “limitesLocalPosterior”. Para ello creamos 3 prototipos que se denominan “PaquetesLocalSuperior”, “PaquetesMismoLocal” y “PaquetesLocalPosterior”, los cuales usaremos para indicar si los paquetes son del local que esta por encima en la matriz, en la misma fila, o en la fila posterior. Creando estos prototipos no solo sacamos una serie de condicionales, sino que también, dejamos de pasarle por parámetro la variable “limite” al método “procesarPaquetesPermitidos” debido a que ahora se encontrará en el objeto instanciado.

13.	Para seguir sacando condicionales de más, decidimos sacar los “else” de los “if” que se encontraban en las filas 139-141 y de 144-146 del método “encolarYProcesar” en el archivo “matrizLocales.js”. Para ellos lo que haremos es que cada vez que se entra al “forEach” de “this.locales.forEach” se seten en los objetos de PaquetesLocalSuperior y PaquetesLocalPosterior los paquetes en 0, y en caso de no ser la primer o ultima fila se cambiaran los valores.

14.	 Se puede eliminar el “while” que se encuentra entre las líneas 192-197 por un forEach del método “encolarPaquetesPermitidos” del archivo matrizLocales.js.

15.	 Se puede eliminar el condicional que se encuentra entre las líneas 193-200 que había sido recientemente refactorizada para eliminar el while, simplemente haciendo que el método “agregarACola” retorne los paquetes que no entraron a la cola, haciendo así que se vaya el condicional, la bandera “l” y la variable “cantidadQuePuedoProcesar”.

16.	 Se puede eliminar el parámetro “localesAgregar” en el prototipo “MatrizLocales” dado que es completamente innecesario, se puede contar el largo de los limitesColaDeEspera y obtener los locales que se quieren agregar. Además sacaremos el “while” que se encuentra entra la línea 12-15 por un forEach, sacando no solo el while, sino que también la variable contador.

17.	 Sacamos el switch en el prototipo paquete, creando una herencia con 3 tipos de paquetes, los muy rápidos, los rápidos, y los normales. De esta forma podemos sacar el switch que se encuentra entre las líneas 19 a 29 del prototipo paquetes, además de sacarle un parámetro: “urgenciaSolicitada”.

18.	 El siguiente cambio requiere de varias aclaraciones. Primero que nada la idea fue sacar la variable filasAMoverse en el método “analizarMovimientos”, para ello debíamos hacer que cada paquete supiese en que fila se encuentra y además que tenga un método para retornas cuantas filas debe moverse. El método que agregamos entonces fue “filasAMoverse” en el prototipo paquetes, que hace lo mismo que hacíamos para calcular la variable en “analizarMovimientos” de matrizLocales.js. Para el tema de saber en que fila estaba decidimos primero que nada que cuando se agregan paquetes a la cola de salida, que se pase por parámetro el nombre del local, entonces la cola de salida les pondrá el valor de la fila correspondiente a cada paquete. Luego en el método “encolarYProcesar” del archivo matrizLocales.js agregamos que cuando un paquete se mueve, se le actualiza la fila, de esta forma los paquetes sabrán su fila constantemente, y debemos olvidarnos no solo de utilizar la variable “filasAMoverse” anteriormente mencionada sino que también debemos dejar de pasarle por parámetro dicho valor a el método “aCualMoverme”. A su vez, podemos dejar de usar el parámetro “filaQueEstoy” al método “aCualMoverme” ya que ahora el dato lo tiene el paquete también, como consecuencia tampoco es necesaria la bandera en el método “analizarMovimientos”. El mismo cambio podemos realizar con la variable “columnasQueQuedan”, generando un método en el prototipo paquete que retorne cuantas columnas quedan el cual dominamos “columnasQueQuedan”, y actualizamos en que columna se encuentra el paquete en cada tiempo. De esta forma no solo eliminamos la bandera “columnasQueQuedan” en el método “analizarMovimientos” sino que también dejamos de pasarle por parámetro la variable “columnasQueQuedan” al método “aCualMoverme”.

19.	 Por otro lado el código de matrizLocales.js es muy extenso por lo que el método “aCualMoverme”, lo delegaremos al prototipo Paquete dado que solo se utilizan métodos y variables de dicho prototipo. Con este cambio logramos sacar uno de los últimos parámetros “paquete” dado que no hace falta que cuando llamamos a la funcion del objeto, se los pasemos por parámetro, dejando así en el método “aCualMoverme” un único parámetro que corresponde a ”subirOBajar”. Y habiendo reducido finalmente el código de matrizLocales.js de 210 líneas a 150.

2_ Duplicted code: Podemos extraer la funcion, slide statements (si uno se encuentra con el codigo no es identico), pull up method (si el codigo se encuentra en subclases)
3_ Code smells, funciones con mas de 10 lineas de codigo deben hacernos dudar: Podemos extraer la funcion, si posee demasiados parametro ponerlos en un objeto
4_ Longo parameter list, no se pueden tener mas de tres o cuatro parametros en el método.
5_ fijarse si un cambio dispara errores en varias clases o si tira varios errores en una sola clase.
6_ Feature envy: sucede cuando un modulo se pasa mas hablando con otro modulo que con sus propias caracteristicas.
7_ Data clumps: si una clase contiene variables repetidad deberian agruparse en una unica clase propia.

MEGA IMPORTANTE
8_REPEATED SWITCHES: no se deben usar las sentencias de decision: reemplzarlas por un condicional
MEGA IMPORTANTE

9_ Podemos decir que usamos lo de sacar los loops.

10_ Speculative generality: una funcionalidad que, al momento de diseño se penso que iba a ser genial, pero en realidad nunca fue necesaria (nombre en los centros)
11_ Temporay field: un campo de un objeto que solo es util en determinadas circunstancias.
12_ Massage chains¿?
13_ Middel man una clase que lo unico que hace es delegar la tarea a otra clase
14_ Insider trading: los modulos deben ser desiñados de forma solida y al intercambiar datos en exceso aumenta el acomplamiento
15_Large class, una clase con demsiados campos, metodos y lineas de codigo.
16_ Alternative classes with diferrent interfaces: dos clases que realizan la misma funcionalidad pero sus interfaces son diferentes (nombres o parametros)
17_ Data class, una clase que solo contiene valores en sus propiedades y su funcionalidad solo se limita a setter y getters.
18_ Replace superclass with delegate: lo tenemos
19_ Principio SRP (delegar actividades)
20_ OCP: que un cambio en un modulo no delege en una cascada de errores
21_ ISP: separar interfaces de manera tal que podamos tener interfaces mas pequeñas y que no todas deban obtenrse de la misma.
